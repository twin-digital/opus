name: Publish

on:
  # watch for CI workflow to finish
  workflow_run:
    branches: [main]
    types:
      - completed
    workflows: ['CI']

concurrency: ${{ github.workflow }}-${{ github.ref }}

env:
  CI: 1
  HUSKY: 0
  TURBO_TELEMETRY_DISABLED: 1

jobs:
  publish:
    # only run when CI passed
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    outputs:
      hasChangesets: ${{ steps.changesets.outputs.hasChangesets }}
      published: ${{ steps.changesets.outputs.published }}
    steps:
      # checkout project
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.CHANGESETS_GITHUB_TOKEN }}
          fetch-tags: true

      # setup tools and install dependencies
      - name: Setup dependencies
        uses: ./.github/actions/setup

      # configure git to ignore executable bit on files and remove executable bits from all files
      # (except node_modules) to prevent publishing failures via github-api
      - name: Configure git file mode and remove executable bits
        run: |
          git config core.fileMode false
          find . -type f -not -path "*/node_modules/*" -executable -exec chmod -x {} +
        shell: bash

      # perform changesets release operations
      - name: Create Publish Pull Request or Publish to npm
        id: changesets
        uses: changesets/action@v1
        with:
          commitMode: github-api
          publish: pnpm publish-packages
        env:
          GITHUB_TOKEN: ${{ secrets.CHANGESETS_GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

  # Prepare matrix of Docker packages to build
  docker-matrix:
    needs: publish
    if: needs.publish.outputs.hasChangesets == 'false'
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.detect.outputs.packages }}
      has-packages: ${{ steps.detect.outputs.has-packages }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.CHANGESETS_GITHUB_TOKEN }}
          fetch-tags: true

      - name: Setup dependencies
        uses: ./.github/actions/setup

      - name: Detect Docker packages
        id: detect
        run: |
          packages=$(node ./tooling/scripts/bin/docker-packages.js)
          echo "packages=$packages" >> $GITHUB_OUTPUT
          if [ "$packages" = "[]" ]; then
            echo "has-packages=false" >> $GITHUB_OUTPUT
          else
            echo "has-packages=true" >> $GITHUB_OUTPUT
          fi

  # Build and publish Docker images in parallel
  docker-build-publish:
    needs: docker-matrix
    if: needs.docker-matrix.outputs.has-packages == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix:
        package: ${{ fromJson(needs.docker-matrix.outputs.packages) }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup dependencies
        uses: ./.github/actions/setup

      - name: Build Docker image
        run: pnpm run artifact --filter=${{ matrix.package.name }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load, tag, and push Docker image
        run: |
          # Get the image ID from the build artifact
          IMAGE_ID=$(cat ./${{ matrix.package.path }}/.out/image.iid)

          # Load image from artifact
          docker load < ./${{ matrix.package.path }}/.out/container-image.tar.gz

          # Parse version components
          VERSION="${{ matrix.package.version }}"
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f1-2)
          PATCH=$VERSION

          # Tag with all version variants
          docker tag $IMAGE_ID ${{ matrix.package.imageName }}:latest
          docker tag $IMAGE_ID ${{ matrix.package.imageName }}:$PATCH
          docker tag $IMAGE_ID ${{ matrix.package.imageName }}:$MINOR
          docker tag $IMAGE_ID ${{ matrix.package.imageName }}:$MAJOR

          # Push all tags
          docker push ${{ matrix.package.imageName }}:latest
          docker push ${{ matrix.package.imageName }}:$PATCH
          docker push ${{ matrix.package.imageName }}:$MINOR
          docker push ${{ matrix.package.imageName }}:$MAJOR

  # Check Docker build status and fail workflow if any builds failed
  docker-status-check:
    needs: [publish, docker-matrix, docker-build-publish]
    if: always() && needs.publish.outputs.hasChangesets == 'false' && needs.docker-matrix.outputs.has-packages == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Check Docker build results
        run: |
          if [ "${{ needs.docker-build-publish.result }}" != "success" ]; then
            echo "Docker build and publish failed"
            exit 1
          fi
